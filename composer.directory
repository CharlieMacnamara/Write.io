You are an expert in TypeScript (5.x), Node.js (20.x), Next.js App Router (14.2.x), React (18.x), DaisyUI (4.x), and Tailwind CSS (3.x).

Code Style and Structure
- Write concise, technical TypeScript code with accurate examples.
- Use functional and declarative programming patterns; avoid classes.
- Prefer iteration and modularization over code duplication.
- Use descriptive variable names with auxiliary verbs (e.g., isLoading, hasError).
- Structure files (Maintain existing structure): exported component, subcomponents, helpers, static content, types.

Naming Conventions
- Use lowercase with dashes for directories (e.g., components/lesson-card).
- Favor named exports for components.

TypeScript Usage
- Use TypeScript for all code; prefer interfaces over types.
- Avoid enums; use const objects for fixed values.
- Use functional components with TypeScript interfaces.

UI and Styling
- Use DaisyUI 4.x components with Tailwind CSS 3.x customization.
- Implement responsive design with Tailwind CSS; use a mobile-first approach.
- Use Tailwind's built-in animation classes for gamification elements.
- Use Headless UI 1.7.x for accessibility
- Use Tailwind Merge 2.x for utility merging
- Use clsx 2.x for conditional classes
- Use Lucide React 0.344.x for icons
- Use React-Hot-Toast 2.4.x for notifications
- Use next-themes 0.2.x for dark mode

Performance Optimization
- Minimize 'use client', 'useEffect', and 'setState'.
- Implement proper code splitting for lesson content.
- Use dynamic loading for non-critical components.
- Optimize images: use WebP format, include size data, implement lazy loading.

Gamification Features
- Use localStorage for progress tracking.
- Implement achievement system with DaisyUI badges.
- Add progress bars and animations for completion tracking.
- Track user writing streaks and milestones.
- Implement level system based on completed lessons.

AI Integration
- Use Google's Gemini API for sentence generation
- Implement proper rate limiting and error handling
- Use streaming responses for real-time feedback
- Cache common AI responses to reduce API costs
- Track token usage for cost optimization
- Implement fallback responses for API limits/errors
- Handle Gemini API quotas and limits
Sanitize and validate Gemini responses
Optimize prompt tokens for cost efficiency
Maintain response quality across difficulties


State Management
- Use Zustand 4.5.x for lightweight state management
- Use zustand/middleware for persistence
- Persist critical user data locally
- Implement optimistic updates for better UX
- Handle offline capabilities where possible

Error Handling
- Implement graceful fallbacks for AI service disruptions.
- Provide meaningful error messages to users.
- Log errors for debugging and monitoring.
- Handle network issues gracefully.

Security
- Implement rate limiting per user.
- Sanitize user inputs before AI processing.
- Validate API responses.
- Protect sensitive endpoints.

Cost Optimization
- Cache frequently requested AI responses.
- Optimize prompts to minimize token usage.
- Batch similar requests where possible.
- Implement request debouncing.
- Monitor and log API usage.

Testing
- Use Jest 29.x for unit testing
- Use React Testing Library 14.x for component testing
- Use @testing-library/jest-dom 6.x for matchers
- Write unit tests for critical business logic.
- Implement E2E tests for main user flows.
- Test error handling and fallbacks.
- Mock AI responses in tests.

Documentation
- Document AI integration setup.
- Maintain prompt engineering guidelines.
- Document state management patterns.
- Keep API usage examples updated.

Dependencies:
- @headlessui/react: ^1.7.x
- @types/node: ^20.x
- @types/react: ^18.x
- autoprefixer: ^10.x
- next: ^14.2.x
- postcss: ^8.x
- react: ^18.x
- react-dom: ^18.x
- tailwindcss: ^3.x
- typescript: ^5.x
- zustand: ^4.5.x

Follow Next.js 14.2.x docs for Data Fetching, Rendering, and Routing.
