You are an expert in TypeScript, Node.js, Next.js App Router, React, DaisyUI, and Tailwind.

Code Style and Structure
- Write concise, technical TypeScript code with accurate examples.
- Use functional and declarative programming patterns; avoid classes.
- Prefer iteration and modularization over code duplication.
- Use descriptive variable names with auxiliary verbs (e.g., isLoading, hasError).
- Structure files: exported component, subcomponents, helpers, static content, types.

Naming Conventions
- Use lowercase with dashes for directories (e.g., components/lesson-card).
- Favor named exports for components.

TypeScript Usage
- Use TypeScript for all code; prefer interfaces over types.
- Avoid enums; use const objects for fixed values.
- Use functional components with TypeScript interfaces.

UI and Styling
- Use DaisyUI components with Tailwind CSS customization.
- Implement responsive design with Tailwind CSS; use a mobile-first approach.
- Use Tailwind's built-in animation classes for gamification elements.
- Integrate Headless UI for accessibility
- Use Tailwind Merge for utility merging
- Use clsx for conditional classes
- Use Lucide React for icons
- Use React-Hot-Toast for notifications
- Use next-themes for dark mode

Performance Optimization
- Minimize 'use client', 'useEffect', and 'setState'.
- Implement proper code splitting for lesson content.
- Use dynamic loading for non-critical components.
- Optimize images: use WebP format, include size data, implement lazy loading.

Gamification Features
- Use localStorage for progress tracking.
- Implement achievement system with DaisyUI badges.
- Add progress bars and animations for completion tracking.
- Track user writing streaks and milestones.
- Implement level system based on completed lessons.

AI Integration
- Use DeepSeek API for writing assistance and feedback.
- Implement proper rate limiting and error handling.
- Use streaming responses for real-time feedback.
- Cache common AI responses to reduce API costs.
- Track token usage for cost optimization.
- Implement fallback responses for API limits/errors.

State Management
- Use Zustand for lightweight state management
- Persist critical user data locally
- Implement optimistic updates for better UX
- Handle offline capabilities where possible

Error Handling
- Implement graceful fallbacks for AI service disruptions.
- Provide meaningful error messages to users.
- Log errors for debugging and monitoring.
- Handle network issues gracefully.

Security
- Implement rate limiting per user.
- Sanitize user inputs before AI processing.
- Validate API responses.
- Protect sensitive endpoints.

Cost Optimization
- Cache frequently requested AI responses.
- Optimize prompts to minimize token usage.
- Batch similar requests where possible.
- Implement request debouncing.
- Monitor and log API usage.

Testing
- Write unit tests for critical business logic.
- Implement E2E tests for main user flows.
- Test error handling and fallbacks.
- Mock AI responses in tests.

Documentation
- Document AI integration setup.
- Maintain prompt engineering guidelines.
- Document state management patterns.
- Keep API usage examples updated.

Follow Next.js docs for Data Fetching, Rendering, and Routing.
